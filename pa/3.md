# PA3: Runtime

In this assignment, you'll extend your Grumpy virtual machine to perform garbage collection and to support the creation and management of threads. 

```
                                                   /--------------\
                                                   |GC+Concurrency| <-- PA3
                                                   \--------------/
                                                         |||
                /-------------\                    /--------------\
<filename.s> => | assemble.rs | => <filename.o> => |     vm       | => program's result
                \-------------/                    \--------------/
                  ^| PA1                                 ^| PA2
```

The assignment has two parts. In the first, you will implement a copying garbage collector for your VM from PA2. In the second, you'll extend your garbage-collected VM to support the creation and management of user-level threads. We discuss each part of the assignment in turn. 

**NOTE: This is a pair assignment, just like PA2.**

1. You're welcome to work with the same person you worked with in PA2 or to choose a new partner.
2. Only one partner need submit.
3. Make sure your `README` contains both partners' names.

## Part O: VM Revisited

Make sure your VM from the previous assignment is in working order. If you need help, come talk to us in office or lab hours.

## Part I: Garbage Collection

Extend your VM from PA2 to perform copying garbage collection. Refer to Appel 13 and to the lecture notes if you forget exactly how copying collection works. 

For **Part I**, your VM extended with garbage collection will have the same interface as your VM from PA2 except that it may additionally perform garbage collections during the execution of a program. In particular, it should: 

1. Accept the name of a GrumpyVM bytecode `<filename.o>` as its first command-line argument;
2. Execute the file, possibly triggering one or more garbage collections;
3. Print the program's result to `stdout` using the textual encoding described in PA2 (`Vi32(-3)` for the integer `-3`, etc.). 

To make it easy for us to test your garbage collector, we ask that you additionally follow these guidelines:

4. Your VM should trigger a garbage collection *exactly when* the program attempts to `Alloc` an object that would not fit in the heap. For example, if the heap is occupied by `1000` of `1024` possible values (`1024` values being the size of the heap as specified in PA2), and the program attempts to allocate an object of size `25` values, your VM must trigger a garbage collection.

5. On each garbage collection, your VM must print to `stderr` (NOTE: not `stdout`!) exactly the following metadata:

```
GC start: heap_size = X values
GC end: heap_size = Y values
```

where `X` is the number of values in the heap right before the collection and `Y` is the number of values after. 

6. If your VM cannot complete an allocation even after a GC, your VM should exit with a nonzero error code. Make sure, in this case, that you've printed intermediate GC statistics to `stdout` as directed above (that is, those generated by GCs before your VM ran out of memory).

### Testing Part I

You can test your solution to Part I even before you've begun Part II. To do so, run your `vm` on one of the following four test cases: 

```
tests/fact2.o
tests/heap.o
tests/heap2.o
tests/heap3.o
```

**Example:** The command:

```
> ./vm tests/heap3.o 2> gc-stats
```

should produce output:

```
Vi32(10)
```

on `stdout`. 

The `2>` redirects `stderr` to file `gc-stats` which should contain exactly the text:

```
GC start: heap_size = 1012 values
GC end: heap_size = 103 values
```

The program we used to generate `tests/heap3.o` was: 

```
(fun f (x i32) -> i32
  (cond (== x (/ 3 1))
    3
    (seq (alloc 100 false) (f (- x 1)))))
    
(fun g (x i32) -> i32
  (let a (alloc 1 (alloc 100 10))
    (seq (f 15)
         (get (get a 0) 50))
    ))
%
(g 0)
```

You can decipher this program by reading the [GrumpyIR Documentation](../doc/ir.md).

An example program on which your garbage-collected VM **should fail** is `tests/fact2.o`. Try running:

```
> ./vm tests/fact2.o
```

Your VM should print to `stderr` the statistics: 

```
GC start: heap_size = 1010 values
GC end: heap_size = 1010 values
```

but then immediately exit with a nonzero error code. Our VM produces: 

```
> ./vm tests/fact2.o
> echo $?
101
```

The program that generated `fact2.o` was:

```
(fun fact (x i32) -> i32
  (let a (alloc 100 0) 
       (seq (set a 0 x)
            (let y (get a 0)
                   (cond (== 0 y) 1 (* y (fact (- y 1))))))))
%
(fact 12)
```

## Part II: Concurrency

Implement in your VM the following additional instructions:

### Print

Print a character to `stdout`.

Pre-state:

| stack |
| ----- |
| Vi32(i) STACK_TOP |

Post-state:

| stack |
| ----- |
| STACK_TOP |

Side-effect:

Print to `stdout` the ASCII representation of the low-order byte of integer `i`.

### Spawn

Spawn a new thread. 

Pre-state (parent thread):

| stack |
| ----- |
| Vaddr(closure) STACK_TOP |

| heap |
| ---- |
| Vsize(closure_size) funptr fv_(N-1) fv_(N-2) ... fv_0 |
| ^closure |

Argument `closure` is the address of a closure in the heap: a function pointer followed by values of the function's free variables at the time the closure was created. 

Post-state (parent thread):

| stack |
| ----- |
| STACK_TOP |

Side-effect:

Create a new child thread with initial state:

| stack | pc |
| ----- | -- |
| Vaddr(closure) Vunit Vloc(0) Vloc(0) STACK_TOP | funptr |

| heap |
| ---- |
| Vsize(closure_size) funptr fv_(N-1) fv_(N-2) ... fv_0 |
| ^closure |

The parent thread's heap should be *copied* for the child, at which point the two threads' heaps may diverge (no shared memory).

### Instruction Encoding 

When extending your VM, assume that the instructon encoding scheme from the [Grumpy VM Documentation](../doc/vm.md) has been updated as follows:

| Instruction | Bytecode | 
| ----------- | -------- | 
| Push(v)     | 0b00000000 Bytecode(v) | 
| Pop         | 0b00000001 |
| Peek(i:u32) | 0b00000010 byte3(i) byte2(i) byte1(i) byte0(i) (big-endian) |
| Unary(u)    | 0b00000011 Bytecode(u) |
| Binary(b)   | 0b00000100 Bytecode(b) | 
| Swap        | 0b00000101 |
| Alloc       | 0b00000110 | 
| Set         | 0b00000111 | 
| Get         | 0b00001000 | 
| Var(i:u32)  | 0b00001001 byte3(i) byte2(i) byte1(i) byte0(i) (big-endian) |
| Store(i:u32)| 0b00001010 byte3(i) byte2(i) byte1(i) byte0(i) (big-endian) |
| SetFrame(i:u32)| 0b00001011 byte3(i) byte2(i) byte1(i) byte0(i) (big-endian) |
| Call        | 0b00001100 |
| Ret         | 0b00001101 |
| Branch      | 0b00001110 |
| Halt        | 0b00001111 |
| Spawn       | 0b00010000 |
| ...         |            |
| Print       | 0b00010100 |

That is, `spawn` has opcode `16` while `print` has opcode `20`.

### Managing and Scheduling Threads

To support `spawn`, update your VM to run multiple threads using a scheduling policy of your choosing (e.g., round robin). Since spawned threads cannot yield to one another (there is no `yield` instruction), your concurrency model should be preemptive. That is, each thread should be allowed to run for only a fixed number of instructions (its "quantum") before scheduling the next thread. You are free to choose quantum.

### Termination and Return Results

Some concurrency models distinguish a "main" thread (e.g., the first one) from the remaining threads, halting the machine when the main thread halts. Your VM should instead halt only when *all* the threads on the machine have halted. The return result of a multithreaded computation in GrumpyVM is the return value of the first thread. **Print this return result to `stdout` just as you did in Part I and in PA2.**

### Testing Part II

We've provided some additional tests cases in `./tests` to help you with Part II. They are:

```
tests/conc-spawn1.o
tests/conc-spawn2.o
tests/conc-spawn3.o
tests/print.o
```

**Example:** `print.o` was generated by a program that prints the message `hi there`: 

```
%
(let h 104
(let i 105
(let t 116
(let e 101
(let r 114
(let space 32
(seq (print h)
(seq (print i)
(seq (print space)
(seq (print t)
(seq (print h)
(seq (print e)
(seq (print r)
(print e))))))))))))))
```

On `./vm tests/print.o`, your VM should produce: 

```
> ./vm tests/print.o
hi thereVunit
```

The `Vunit` was inserted by our compiler as the result of the final print statement (and therefore also the result of the program; cf. `tests/print.s` for details).

**Example:** `conc-spawn1.o` was generated by a program that spawns a function to print the character 'a' (=`97` in ASCII): 

```
%
(spawn (lam x unit (print 97)))
```

The result of `./vm tests/conc-spawn1.o` should be: 

```
> ./vm tests/conc-spawn1.o
aVunit
```

The spawned thread prints `a` then halts. The first thread (which spawned the function to print `a`) halts either before or after the spawned thread. The result of the whole program is the result of the main thread, which in this case is `Vunit` (our compiler pushes a `Vunit` after the `spawn` instruction; cf. `tests/conc-spawn1.s` for details). 

**Example:** As a final test case, consider program `tests/conc-spawn3.gpy`:

```
%
(let f (lam c i32 (lam x unit (print c)))

(let a 97
(let b 98

(seq (spawn (app f a))
     (spawn (app f b))))))
```

When you run your VM on the compiled bytecode `tests/conc-spawn3.o`, you should get either:

```
> ./vm tests/conc-spawn3.o
abVunit
```

or

```
> ./vm tests/conc-spawn3.o
baVunit
```

depending on your scheduling policy (whether you run `f a` or `f b` first).

## Extra Credit

For one or two points of extra credit:

* Implement channels as described in lecture.
* Demonstrate at least one test multithreaded program that uses your channel primitive to communicate between threads.
* In a one page design document, describe your implementation and any pitfalls you encountered along the way.

## Submission

1. You must use one of the following languages to implement your VM's runtime system: Rust, C, C++, Python, OCaml. In order for us to support submissions in multiple languages, we ask that *all* submissions contain at least the following three files:
   
   ```
   README               <-- A short text document describing your project's architecture
   Makefile             <-- The Makefile used to build your project
   main.<rs|c|cc|py|ml> <-- Your project's root file
   ```
   
   NOTES:
   * Your Makefile should contain the following targets:
      - `build` which will build your vm (it doesn't need to do anything for Python but must still exist).
      - `run` which will run your vm. It should be called like this `F=<file.o> make run`.
      - `clean` which will clean the build environment
   * We will build your project on `pu2.cs.ohio.edu` (we suggest you test there).
   * You may (optionally) include additional files that are called from `main`.
   * If you use Rust you may use Cargo, however you still need to provide the above Makefile.
      - Hint: Look at `cargo build --release`, it will use optimizations and remove debug symbols so it runs faster.
   * Sample Makefiles for C++ and Rust will be uploaded to Blackboard for you to use.
   
 2. To submit your project, submit all your project files separately in Blackboard, under assignment `pa3`, on or before the due date.
