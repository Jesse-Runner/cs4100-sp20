# PA1: Assembler

Your job in this assignment is to implement an assembler for Grumpy assembly code. That is, you'll be implementing a program `assemble` that reads assembly code for the Grumpy virtual machine (GrumpyVM) and outputs corresponding bytecode. 

```
Assembly language program        Equivalent bytecode program
     |                                  |
     v          /-------------\         v        
<filename.s> => | assemble    | => <filename.o> 
                \-------------/                 
                     ^| This assignment                         
```

There are three main problems to solve: 

1. Translating Grumpy assembly into an in-memory data structure (of your design)
2. Laying out the parsed program in memory in order to resolve labels
3. Printing the resulting bytecode

We discuss each in turn.

## Parsing 

The input to your assembler is a file `<filename>.s` containing text like: 

```
setframe 0
push Lmain
call
halt
Lmain:
push 3
push 12
binary /
ret
```

This program returns the result of the operation `12 / 3`. 

Line by line, the program does the following:

| Instruction | Effect | 
| ----------- | ------ | 
| setframe 0  | Set the frame pointer to 0 |
| push Lmain  | Push the address corresponding to label Lmain onto the stack |
| call        | Call the address corresponding to Lmain |
| halt        | Halt the machine |
| Lmain:      | Declare label Lmain as the address of the following instruction |
| push 3      | Push 3 onto the stack |
| push 12     | Push 12 onto the stack |
| binary /    | Pop 12, pop 3, push (12 / 3) |
| ret         | Return to caller |

Your first step is to write functions for reading such programs from a file, storing them in some sort of internal data structure. One good way to proceed (in the design of your internal data structure) is to define an `enum` in Rust with one constructor for each of the possible instruction types, including the appropriate arguments for each instruction type, etc. 

That is, you might have a type like `Instr` defined beginning as follows: 

```
#[derive(Debug,Clone)]
pub enum Instr {
    Push(Val),     //Push(v): Push value v onto the stack
    Pop,           //Pop a value from the stack, discarding it
    Peek(u32),     //Peek(i): Push onto the stack the ith value from the top
    ...
```

The `pub` in this type declaration makes `Instr` a type accessible in files that import whichever file defines the type. 

> HINT: There's a complete version of such a definition in the GrumpyVM documentation -- you're permitted, but not required, to use this definition.

> If you do use it, note that instructions like Push as defined in the GrumpyVM documentation don't support labels like Lmain as arguments (they require `Val`ues instead). You'll have to update the type (or define another type that uses `Instr` in some way) in order to deal with this. Part of the assignment is figuring these sorts of things out.

Here's a grammar that defines the set of programs your assembler should accept:

```
Unary Operations
u ::= neg

Binary Operations
b ::= + | * | - | / | < | ==

Values 
v ::= tt    //The unit value
    | n     //32-bit two's complement signed integer
    | true  //Boolean literals
    | false 
    | undef //The undefined value

Labels
l ::= L[a-zA-Z]+  //A label is the character 'L' followed by one or more alphabetic characters
    | _L[a-zA-Z]+ //or "_L" followed by one or more alphabetic characters ("_L" is typically reserved 
                  //for fresh labels generated by a compiler producing GrumpyVM assembly).

Instructions
i ::= push v     //Push a value
    | push l     //Push a label
    | pop 
    | peek u32   //Where u32 stands for a 32-bit unsigned integer
    | unary u
    | binary b
    | swap
    | alloc
    | set
    | get
    | var u32
    | store u32
    | setframe u32
    | call
    | ret
    | branch
    | halt

Instructions or Labels
il ::= i         //An "il" is either an instruction 
     | l:        //or a label "l" followed by a colon ":", as in "Lmain:".

Grumpy Assembly Programs
p ::= il_1
      il_2 
      ... 
      il_N
```

Your assembler should be able to handle any assembly program that is valid according to this grammar. If you want additional examples of valid Grumpy assembly programs, take a look at the `.s` files in the `tests` directory.

## Resolving Labels

A program such as

```
setframe 0
push Lmain
call
halt
Lmain:
...
```

contains labels like `Lmain` that stand in for the addresses of instructions in the program. To produce a program that can be executed on the GrumpyVM, your assembler needs to resolve the labels to these instruction addresses. 

For the example program above, the labels could be resolved as:

| Address | Instruction | 
| ------- | ----------- | 
| 0       | setframe u32(0)|
| 1       | push loc(4) |
| 2       | call        |
| 3       | halt        |
| 4       | push i32(3) | 
| 5       | push i32(12)|
| 6       | binary /    |
| 7       | ret         |

Some uses of labels, like `push Lmain`, point to declarations (`Lmain:`) that appear only later in the program. One way to deal with this is to make two passes through the program, the first to resolve the addresses of labels, the second to replace the labels with their resolved addresses. 

*A Note on Instruction Addresses*: When addressing instructions, your assembler should use addresses that correspond to the index of the instruction as it appears in the program. That is, the first instruction (above, `setframe 0`) is at address 0, the second (`push 4`) is at address 1, and so on. In the bytecode representation of GrumpyVM programs (about which more below), each instruction is not necessarily the same size. Instruction addresses therefore abstract from the physical layout of GrumpyVM programs in bytecode; the GrumpyVM (PA2) will resolve this discrepancy when it decodes GrumpyVM bytecode files.

## Printing the Bytecode

The output of your assembler should be a new binary file `<filename>.o` containing the bytecode for `<filename>.s` with all labels resolved. For the program above, this bytecode is:

```
0000000 0000 0008 0b00 0000 0000 0400 0000 040c
0000020 0f00 0100 0000 0300 0100 0000 0c04 030d
0000040
```

as displayed in hexadecimal by the linux command `od --endian big -x <filename.o>` (the first 7 characters of each line, e.g., `0000000`, are the addresses of the beginning of the line).  

How do you figure out the byte-level encodings of GrumpyVM's instructions? Your first point of reference should be the [GrumpyVM documentation](../doc/vm.md), which describes in detail the encodings of all the instructions (in particular, the section you should focus on is **Instruction Bytecode Format**). Stepping through the encodings to reverse engineer the `.o` output above, we get:

| Bytes        | Meaning                  |
| ------------ | ------------------------ |
| 00 00 00 08    | `N`, the number of instructions, equals `8` |
| 0b 00 00 00 00 | Instruction is `setframe` (`opcode = 11`), argument is `0` |
| 00 04 00 00 00 04 | Instruction is `push` (`opcode = 0`), argument is a location (prefix `04`), location is `00 00 00 04` |
| 0c             | Instruction is `call` (`opcode = 12`) |
| 0f             | Instruction is `halt` (`opcode = 15`) |
| 00 01 00 00 00 03 | Instruction is `push` (`opcode = 0`), argument is an i32 (prefix `01`), integer is `00 00 00 03` |
| 00 01 00 00 00 0c | Instruction is `push` (`opcode = 0`), argument is an i32 (prefix `01`), integer is `00 00 00 0c` (`= 12`) |
| 04 03          | Instruction is `binary` (`opcode = 4`), argument is operation `/` (code `03`) |
| 0d             | Instruction is `ret` (`opcode = 13`) |

### Hints

1. GrumpyVM object files begin with a binary encoding of the unsigned 32-bit big-endian integer `N`, the number of instructions (not the number of bytes!) in the program. If you forget to output `N`, the GrumpyVM won't be able to execute your `.o` files.

2. Make sure to test your assembler by running the GrumpyVM on the object files you generate, for a variety of test programs. We will test your assembler against both student tests and against a test suite that we have designed.

3. Take a look at the **ByteOrder** crate. It will help you convert integers into the appropriate binary format (remember: all integers, etc., should be encoded in **big-endian** format).

### Testing

One way to test your code is to run it on a variety of GrumpyVM assembly (`.s`) files, ensuring that for each program you output bytecode (a `.o` file) that's runnable by the GrumpyVM (and on which the VM produces the right result!).

To assist you, we've collected a number of sample programs in the [tests](tests) directory. At a high level: 

* Files `<file>.s` are GrumpyVM assembly programs.
* Files `<file>.o` are GrumpyVM bytecode files.

To minimally test your assembler, ensure that for each `<file>` in `tests`, the `.o` file your assembler produces when run on `<file>.s` is **exactly the same** as the reference `<file>.o` that we give you.

Be sure to test your program on the Ubuntu Prime machines before submitting to work out any bugs.

## Specifics

1. Post at least one novel test case to Piazza, as in PA0, in the form of a GrumpyVM assembly program. Title your post with the following pattern. `OAKID - Test Case`. Make sure the test case is public so other students may use it.

2. Use Rust's Cargo program management system to implement a program `assemble` that reads Grumpy assembly programs from `<filename>.s` and outputs the resulting bytecodes to `<filename>.o`. You can assume that `<filename>.s` is the first argument to `assemble` (the zeroth being your assembler's path). **NOTE: You must use Cargo for this assignment. Put all your code in `main.rs`.**

```
Cargo Quickstart
================
1. To initialize a new Cargo project called 'assemble', do

   > cargo init assembler

This command will create a directory `assemble` with the following structure:
   assemble:
     Cargo.toml   /*<-- dependencies and metadata*/
     src/main.rs  /*<-- your code*/

2. To build your project, type 

   > cargo build
   
3. To run your main.rs on <filename>.s, type

   > cargo run <filename>.s
```

3. On valid Grumpy assembly programs, `assemble` should return exit code 0. On invalid programs, your assembler should exit with a nonzero exit code.

4. Submit the following files on Blackboard on or before the due date:
   * `main.rs`
   * `Cargo.toml`
   
   **Please do not zip these files, change their names, or include any other files.**
